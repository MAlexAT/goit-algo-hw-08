import heapq

def min_connection_cost(cables):
    # Побудова мінімальної купи з початкових довжин кабелів
    heapq.heapify(cables)
    
    total_cost = 0  # Змінна для збереження загальних витрат

    # Об'єднуємо кабелі, доки не залишиться один
    while len(cables) > 1:
        # Виймаємо два найкоротші кабелі
        first = heapq.heappop(cables)
        second = heapq.heappop(cables)
        
        # Вартість з'єднання двох кабелів
        cost = first + second
        total_cost += cost
        
        # Виводимо поточне з'єднання і його вартість
        print(f"Об'єднуємо кабелі довжиною {first} і {second}, витрати: {cost}, загальні витрати: {total_cost}")
        
        # Додаємо з'єднаний кабель назад до купи
        heapq.heappush(cables, cost)

    # Повертаємо загальну вартість
    return total_cost

# Приклад використання
cables = [4, 3, 2, 6]
result = min_connection_cost(cables)
print("\nМінімальна сума витрат на з'єднання кабелів:", result)

''' 
**Пояснення коду**
Виведення на кожному кроці: 
Після об'єднання двох кабелів ми виводимо інформацію про їхні довжини, 
витрати на з'єднання та загальні витрати після цього кроку.

Загальні витрати: total_cost постійно накопичує вартість кожного з'єднання, 
і в кінці виводиться підсумковий результат. 
'''